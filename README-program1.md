# program2 - Паралельний Пошук через Work Stealing та Work Dealing

## Опис

Ця програма демонструє два різних підходи до паралельної обробки задач на пошук елемента в двовимірному масиві:

1. **Work Stealing** - Динамічний розподіл задач між потоками.
2. **Work Dealing** - Фіксований розподіл задач між потоками.

# Алгоритм роботи

## 1. Створення випадкового масиву:
Програма генерує двовимірний масив розміру `m x n` із випадковими цілими числами в діапазоні від `0` до `m + n`.

```java
// Створення масиву та його випадкове заповнення
int[][] array = new int[m][n];
Random rand = new Random();
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        array[i][j] = rand.nextInt(m + n + 1);  // Заповнення масиву випадковими числами
    }
}
```

## 2. Work Stealing (Динамічний розподіл задач):

Масив розбивається на рядки, і кожен рядок обробляється в окремому потоці. Якщо один потік завершив свою роботу, він може "вкрасти" роботу у іншого потоку, щоб продовжити обробку.

### Опис:
- Масив розбивається на рядки.
- Для кожного рядка створюється окреме завдання, яке виконуватиметься потоком.
- Якщо потік завершує обробку свого рядка, він може "вкрасти" завдання у іншого потоку, який ще не завершив.

### Код:
```java
if ((rowEnd - rowStart) <= 1){
    Integer result;
    for (int j = colStart; j < colEnd; j++) {
        if (array[rowStart][j] == rowStart + j) {
            result = new Integer(array[rowStart][j]);
            return result;
        }
    }
    return null;
} else {
    ArrayList<SearchStealingTask> tasks = new ArrayList<>();

    for (int i = rowStart; i < rowEnd; i++) {
        SearchStealingTask newRecursiveTask = new SearchStealingTask(array, i, i+1, 0, colEnd);
        tasks.add(newRecursiveTask);
        newRecursiveTask.fork();
    }
    for (SearchStealingTask task : tasks) {
        Integer result = task.join();
        if(result != null) return result;
    }
    return null;
}
```

## 3. Work Dealing (Фіксований розподіл задач):

Масив також розбивається на рядки, але кожен потік обробляє строго один рядок, без можливості передавати задачі між потоками.

### Опис:
- Масив розбивається на рядки.
- Кожен потік обробляє один рядок, і не має можливості "вкрасти" роботу у інших потоків.
- Потоки працюють незалежно один від одного.

### Код:
```java
ExecutorService es = Executors.newFixedThreadPool(2);
ArrayList<SearchDealingTask> dealingTasks = new ArrayList<>();
for (int i = 0; i < m; i++) {
    // Створення завдання для кожного рядка
    dealingTasks.add(new SearchDealingTask(array, i, 0, n));  
}
```

### Алгоритм:
1. Створюється пул потоків з фіксованим розміром за допомогою `Executors.newFixedThreadPool(2)`.
2. Масив розбивається на рядки, і для кожного рядка створюється окреме завдання типу `SearchDealingTask`.
3. Кожен потік обробляє строго один рядок масиву.
4. Потоки працюють незалежно один від одного і не можуть передавати роботу між собою.
5. Завдання виконуються паралельно, кожен потік обробляє свій рядок масиву.
6. Результат виконання збирається після завершення всіх потоків.


## Основні відмінності між Work Stealing і Work Dealing

#### Поділ роботи:
- **Work Stealing** використовує динамічний підхід: потоки можуть "вкрасти" завдання від інших, якщо ті завершили свою роботу.
- **Work Dealing** використовує фіксований підхід: кожен потік працює тільки з певною частиною масиву (в даному випадку — рядком), і не може змінювати свою частину роботи.

#### Ефективність:
- **Work Stealing** може бути більш ефективним, оскільки дозволяє потоку, який завершив роботу, зайнятися іншими завданнями, таким чином використовуючи всі потоки більш ефективно.
- **Work Dealing** може бути менш ефективним, оскільки потоки можуть залишатися без роботи, якщо їх частина завдання обробляється швидше за інші частини.

#### Використання ресурсів:
- **Work Stealing** може призвести до меншого часу виконання, оскільки потоки можуть обробляти різні частини масиву без фіксованого поділу роботи.
- **Work Dealing** може бути менш ефективним, особливо якщо деякі потоки не використовують свій час на повну.

## Основні класи програми:

#### `Main`:
- Головний клас, який керує введенням користувача, створенням масиву та запуском пошукових задач для обох підходів.

#### `SearchDealingTask`:
- Клас, що представляє задачу для пошуку елемента в конкретному рядку масиву (для Work Dealing).

#### `SearchStealingTask`:
- Клас, що представляє задачу для пошуку елемента з динамічним розподілом задач (для Work Stealing).
